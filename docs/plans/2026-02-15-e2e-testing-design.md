# E2E Testing with fhe.rs ↔ HEonGPU Conversion Layer

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Validate that the GPU MulPIR server produces mathematically correct results by cross-checking against the fhe.rs reference implementation, using a raw-coefficient conversion layer.

**Architecture:** Transfer the secret key (i64 coefficients) and database tiles from fhe.rs to HEonGPU. Both sides independently generate keys and encrypt queries from the same secret key. The GPU server processes its query, decrypts, and compares the result against the expected tile. Additionally, transfer the fhe.rs query ciphertext (coefficient-form u64 arrays) to HEonGPU for cross-library ciphertext processing. Force matching Q primes via `set_coeff_modulus_values()`.

**Tech Stack:** Rust (fhe.rs), C++20/CUDA (HEonGPU), GoogleTest, shell script orchestration

---

## Key Technical Facts

1. **Q primes must match.** fhe.rs and HEonGPU auto-generate different primes from the same bit sizes because HEonGPU also allocates P primes. Fix: use `set_coeff_modulus_values()` with exact fhe.rs prime values.
   - fhe.rs Q primes: `[0x3FFFFFFFFC001, 0x7FFFFFFFFB4001, 0x7FFFFFFFEAC001]`
   - P prime (HEonGPU only): `0x7FFFFFFFE90001` (any valid 55-bit prime not in Q)

2. **NTT roots may differ** between libraries. Transfer data in coefficient form (PowerBasis), let each side apply its own forward NTT.

3. **fhe.rs Ciphertext access:** `ct[0].coefficients()` returns `ArrayView2<u64>` (NTT form). Must convert to PowerBasis before export. For protobuf route: `to_bytes()` already converts to PowerBasis.

4. **fhe.rs key fields are private** (`pub(crate)`). Cannot access raw key data directly. Must use protobuf serialization or generate fresh keys from imported secret key.

5. **Secret key format:** fhe.rs stores as `i64[8192]` coefficients (ternary: -1, 0, 1). HEonGPU stores as `u64[Q_size * N]` in NTT form. Conversion: map i64 → u64 (mod qi), then forward NTT.

6. **Query encoding difference:** fhe.rs uses `inv = inverse(2^level, t)` as selection value. Must match this on GPU side.

---

### Task 1: Add exact Q prime values to config.hpp

**Files:**
- Modify: `mulpir-gpu-server/include/config.hpp`
- Modify: `mulpir-gpu-server/tests/test_helpers.hpp`
- Modify: `mulpir-gpu-server/src/server/pir_server.cpp`

**Step 1: Update config.hpp with exact prime values**

Add to `BFVConfig`:
```cpp
/// Exact Q moduli prime values matching fhe.rs.
/// Generated by fhe.rs for degree=8192, bits=[50, 55, 55].
/// Both libraries use SEAL convention (primes ≡ 1 mod 2N).
static constexpr std::array<uint64_t, 3> Q_MODULI = {
    0x3FFFFFFFFC001ULL,   // 50-bit
    0x7FFFFFFFFB4001ULL,  // 55-bit
    0x7FFFFFFFEAC001ULL,  // 55-bit
};

/// P modulus for HEonGPU key switching (not used by fhe.rs).
/// Must be a valid NTT-friendly prime not in Q_MODULI.
static constexpr uint64_t P_MODULUS = 0x7FFFFFFFE90001ULL;  // 55-bit
```

**Step 2: Update test_helpers.hpp to use exact values**

Change `create_test_context()` to use `set_coeff_modulus_values()`:
```cpp
inline HEContextPtr create_test_context() {
    auto context = heongpu::GenHEContext<heongpu::Scheme::BFV>();
    context->set_poly_modulus_degree(BFVConfig::POLY_DEGREE);
    context->set_coeff_modulus_values(
        {BFVConfig::Q_MODULI[0], BFVConfig::Q_MODULI[1], BFVConfig::Q_MODULI[2]},
        {BFVConfig::P_MODULUS}
    );
    context->set_plain_modulus(BFVConfig::PLAINTEXT_MODULUS);
    context->generate();
    return context;
}
```

**Step 3: Update pir_server.cpp similarly**

Change `set_coeff_modulus_bit_sizes()` → `set_coeff_modulus_values()`.

**Step 4: Build and run existing tests**

Run: `cmake --build build --parallel && cd build && ./mulpir_tests`
Expected: All 17 tests pass (same as before — just using explicit prime values now)

**Step 5: Commit**

```bash
git add mulpir-gpu-server/include/config.hpp mulpir-gpu-server/tests/test_helpers.hpp mulpir-gpu-server/src/server/pir_server.cpp
git commit -m "feat(mulpir): use exact Q prime values matching fhe.rs"
```

---

### Task 2: Fix and rewrite generate_test_vectors.rs

**Files:**
- Modify: `crates/fhe/examples/generate_test_vectors.rs`

The existing file has compilation errors (missing deps, wrong trait bounds). Rewrite it to:
1. Fix all compilation errors
2. Output raw coefficient data (not protobuf) for cross-library transfer
3. Export: secret key, query ciphertext in coefficient form, tiles, parameters, expected result

**Step 1: Fix Cargo.toml if needed**

Check that `crates/fhe/Cargo.toml` has the required dependencies for the example:
- `clap` with `derive` feature
- `serde` and `serde_json`
- `anyhow` (or replace with `Box<dyn Error>`)
- `tracing` and `tracing-subscriber` (or replace with `println!`)

If deps are missing, use simpler alternatives (println instead of tracing, Box<dyn Error> instead of anyhow).

**Step 2: Rewrite generate_test_vectors.rs**

Key output files:
- `params.json` — PIR dimensions, prime values, query indices
- `tiles.bin` — `[num_tiles: u64][tile_size: u64][tile_0_bytes...][tile_1_bytes...]`
- `secret_key.bin` — `[num_coeffs: u64][coeff_0: i64]...[coeff_N-1: i64]`
- `query_{idx}.bin` — `[num_moduli: u64][degree: u64][c0_q0_coeffs: u64 * N]...[c1_qM_coeffs: u64 * N]`
  - Coefficients in **PowerBasis** (coefficient form), raw u64 per RNS modulus
- `expected_{idx}.bin` — raw tile bytes for verification

For the query ciphertext export, the critical step is converting NTT → PowerBasis before writing:
```rust
// Access raw coefficients - ciphertext is in NTT form
// Use to_bytes() to get PowerBasis proto, then parse to extract raw coeffs
// OR: clone, change_representation, extract coefficients
```

Since `Ciphertext` fields are accessible via `Deref<Target=[Poly]>` and `Poly` has a public `coefficients()` method, but ciphertexts are enforced to be in NTT:
- Option A: serialize via `to_bytes()`, parse protobuf, extract coefficient bytes, unpack bit-packed values
- Option B: access `ct[0].coefficients()` (NTT form), write those — but then C++ must use matching NTT or do INTT+NTT

Option A is cleanest because `to_bytes()` already handles the NTT→PowerBasis conversion internally. Use prost to decode the protobuf and extract the raw polynomial data.

```rust
use prost::Message;

// Serialize ciphertext (automatically converts to PowerBasis)
let ct_bytes = query_ct.to_bytes();

// Decode protobuf to access raw polynomial bytes
let ct_proto = fhe::proto::bfv::Ciphertext::decode(&ct_bytes[..])?;

// Each ct_proto.c[i] is a serialized Poly (Rq proto)
// Decode each to get raw coefficients per modulus
for poly_bytes in &ct_proto.c {
    let rq = fhe::proto::rq::Rq::decode(&poly_bytes[..])?;
    // rq.coefficients contains bit-packed u64 values
    // rq.degree tells us the polynomial degree
    // Unpack using transcode_from_bytes logic
}
```

Actually, a simpler approach: since fhe.rs's `Poly::from_bytes()` and `coefficients()` are public, and we're inside the `fhe` crate's examples:

```rust
// Access polynomials directly via Deref
let c0 = &query_ct[0];  // Poly reference
let c1 = &query_ct[1];

// These are in NTT form. Get the context to know moduli:
let ctx = c0.ctx();
let moduli = ctx.moduli();

// For export, serialize via to_bytes which converts to PowerBasis:
let ct_bytes = query_ct.to_bytes();
// Then parse proto and extract...
```

The simplest working approach: call `to_bytes()` on the ciphertext, which serializes in PowerBasis. Then use `Ciphertext::from_bytes()` to deserialize back into an object we can inspect. But this creates a new ciphertext in PowerBasis which we can then call `.coefficients()` on.

Wait — we can't because `from_bytes` enforces NTT representation too. Let me check...

Actually, looking at the serialization code more carefully: `to_bytes()` converts to PowerBasis proto bytes. We just need to write those coefficient bytes in our raw format. The protobuf contains the bit-packed coefficient bytes which we can unpack using `transcode_from_bytes`.

For the plan, I'll specify both the proto parsing approach and document the exact format.

**Step 3: Build and run**

Run: `cargo run --release -p fhe --example generate_test_vectors -- --output-dir mulpir-gpu-server/test_vectors --num-tiles 16 --tile-size 1024`
Expected: Creates files in `mulpir-gpu-server/test_vectors/`

**Step 4: Commit**

```bash
git add crates/fhe/examples/generate_test_vectors.rs
git commit -m "feat(mulpir): rewrite test vector generator with raw coefficient export"
```

---

### Task 3: Write C++ raw coefficient loader

**Files:**
- Rewrite: `mulpir-gpu-server/tests/test_vector_loader.hpp`

**Step 1: Implement full TestVectors::load()**

The loader must:
1. Read `params.json` (use nlohmann/json or manual parsing)
2. Read `tiles.bin` (header + raw bytes)
3. Read `secret_key.bin` (i64 coefficients → construct HEonGPU SecretKey)
4. Read `query_{idx}.bin` (u64 PowerBasis coefficients → construct HEonGPU Ciphertext → forward NTT)
5. Read `expected_{idx}.bin` (raw tile bytes for verification)

For constructing HEonGPU objects from raw data, use the save/load round-trip approach:
- Build a binary stream matching HEonGPU's native `save()` format
- Call `load()` on the stream
- This avoids needing access to private members

```cpp
// Construct ciphertext from raw PowerBasis coefficients
Ciphertext load_ciphertext_from_raw(
    HEContextPtr context,
    const std::vector<uint64_t>& raw_coeffs,  // [c0_q0..., c0_q1..., c1_q0..., c1_q1...]
    int num_moduli,
    int ring_size,
    bool in_ntt_domain = false
) {
    // Build HEonGPU binary stream
    std::ostringstream oss(std::ios::binary);
    auto scheme = heongpu::scheme_type::bfv;
    int cipher_size = 2;
    auto st = heongpu::storage_type::HOST;
    bool relin = false, generated = true;
    uint32_t mem_size = cipher_size * num_moduli * ring_size;

    oss.write((char*)&scheme, sizeof(scheme));
    oss.write((char*)&ring_size, sizeof(int));
    oss.write((char*)&num_moduli, sizeof(int));
    oss.write((char*)&cipher_size, sizeof(int));
    oss.write((char*)&in_ntt_domain, sizeof(bool));
    oss.write((char*)&st, sizeof(st));
    oss.write((char*)&relin, sizeof(bool));
    oss.write((char*)&generated, sizeof(bool));
    oss.write((char*)&mem_size, sizeof(uint32_t));
    oss.write((char*)raw_coeffs.data(), sizeof(uint64_t) * mem_size);

    // Load into HEonGPU ciphertext
    Ciphertext ct;
    std::istringstream iss(oss.str(), std::ios::binary);
    ct.load(iss);
    ct.set_context(context);
    return ct;
}
```

For the secret key, similar approach — build HEonGPU binary format from raw i64 coefficients:
```cpp
// Convert i64 secret key coefficients to HEonGPU format
// i64 values (-1, 0, 1) → u64 values (qi-1, 0, 1) for each modulus qi
// Then write in HEonGPU SecretKey binary format
```

**Step 2: Verify loading works**

Write a simple test that loads test vectors and checks they're non-null:
```cpp
TEST_F(CompatibilityTest, TestVectorsLoaded) {
    EXPECT_TRUE(vectors_.is_valid());
    EXPECT_FALSE(vectors_.tiles.empty());
    EXPECT_FALSE(vectors_.queries.empty());
}
```

**Step 3: Commit**

```bash
git add mulpir-gpu-server/tests/test_vector_loader.hpp
git commit -m "feat(mulpir): implement raw coefficient loader for fhe.rs test vectors"
```

---

### Task 4: Rewrite test_compat.cu with full e2e verification

**Files:**
- Modify: `mulpir-gpu-server/tests/test_compat.cu`

**Step 1: Write SharedSecretKeyPIR test**

This test validates mathematical equivalence:
1. Load secret key from fhe.rs
2. Generate fresh Galois + Relin keys from imported secret key in HEonGPU
3. Load database tiles
4. Create and encrypt a query (HEonGPU-side, same selection vector construction as fhe.rs)
5. Run full PIR pipeline
6. Decrypt result
7. Decode and compare bytes against expected tile

```cpp
TEST_F(CompatibilityTest, SharedSecretKeyPIR) {
    // Import fhe.rs secret key and generate HEonGPU keys from it
    auto& sk = vectors_.secret_key;
    auto& gk = vectors_.galois_key;  // Generated from imported sk
    auto& rk = vectors_.relin_key;   // Generated from imported sk

    // Load database
    database::DatabaseManager db(context_, ServerConfig{});
    db.load_database(vectors_.tiles);
    const auto& dims = db.dimensions();

    // Create PIR engine with HEonGPU-native keys
    pir::PIREngine engine(context_, gk, rk, db);

    // For each test query
    for (const auto& [idx, expected_bytes] : vectors_.expected) {
        // Create query matching fhe.rs encoding:
        // inv = modular_inverse(2^expansion_level, plaintext_modulus)
        // selection_vector[row] = inv
        // selection_vector[dim1 + col] = inv

        // ... encrypt, process, decrypt, decode, compare bytes ...

        EXPECT_EQ(decoded_bytes, expected_bytes)
            << "Tile mismatch at index " << idx;
    }
}
```

**Step 2: Write CrossLibraryCiphertext test (if ciphertext transfer works)**

This is the harder test — import fhe.rs query ciphertext and process it:
1. Load fhe.rs query ciphertext (PowerBasis coefficients)
2. Apply forward NTT in HEonGPU
3. Process through PIR pipeline
4. Decrypt with imported secret key
5. Compare result

```cpp
TEST_F(CompatibilityTest, CrossLibraryCiphertext) {
    // Load fhe.rs encrypted query
    // Apply NTT conversion
    // Process through PIR pipeline
    // Decrypt and verify
}
```

**Step 3: Run tests**

Run: `cd mulpir-gpu-server/build && cmake --build . --parallel && ./mulpir_tests --gtest_filter='Compat*'`
Expected: All compat tests pass

**Step 4: Commit**

```bash
git add mulpir-gpu-server/tests/test_compat.cu
git commit -m "feat(mulpir): add cross-library e2e compatibility tests"
```

---

### Task 5: Update build system and orchestration script

**Files:**
- Modify: `mulpir-gpu-server/CMakeLists.txt` (add nlohmann/json if needed)
- Modify: `mulpir-gpu-server/scripts/generate_test_vectors.sh`
- Create: `mulpir-gpu-server/scripts/run_e2e_tests.sh`

**Step 1: Update CMakeLists.txt**

Add JSON parsing library (nlohmann/json via FetchContent or CPM) if params.json needs structured parsing. Alternative: use a simpler binary `params.bin` format to avoid the dependency.

**Step 2: Write run_e2e_tests.sh**

```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

echo "=== MulPIR E2E Tests ==="

# Step 1: Generate test vectors from fhe.rs
echo "Step 1: Generating test vectors from fhe.rs..."
"$SCRIPT_DIR/generate_test_vectors.sh"

# Step 2: Build C++ tests
echo "Step 2: Building GPU tests..."
cmake --build "$PROJECT_DIR/build" --target mulpir_tests --parallel

# Step 3: Run compatibility tests
echo "Step 3: Running compatibility tests..."
cd "$PROJECT_DIR/build"
./mulpir_tests --gtest_filter='Compat*'

echo ""
echo "=== All E2E tests passed! ==="
```

**Step 3: Commit**

```bash
git add mulpir-gpu-server/scripts/ mulpir-gpu-server/CMakeLists.txt
git commit -m "feat(mulpir): add e2e test orchestration scripts"
```

---

### Task 6: Run full e2e pipeline and verify

**Step 1: Run the complete pipeline**

```bash
cd mulpir-gpu-server
./scripts/run_e2e_tests.sh
```

Expected output:
```
=== MulPIR E2E Tests ===
Step 1: Generating test vectors from fhe.rs...
Step 2: Building GPU tests...
Step 3: Running compatibility tests...
[==========] Running N tests from 1 test suite.
[  PASSED  ] N tests.
=== All E2E tests passed! ===
```

**Step 2: Verify no regressions**

```bash
cd build && ./mulpir_tests
```

Expected: All tests pass (existing + new compat tests)

**Step 3: Final commit**

```bash
git add -A
git commit -m "feat(mulpir): complete e2e testing with fhe.rs conversion layer"
```
